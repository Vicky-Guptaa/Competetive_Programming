{
    "Disjoint Set": {
        "prefix": "dsu",
        "body": [
            "class DisjSet",
            "{",
            "    int *parent;",
            "    int *rank;",
            "    int size;",
            "",
            "public:",
            "    DisjSet(int capacity)",
            "    {",
            "        size = capacity;",
            "        parent = new int[size];",
            "        rank = new int[size];",
            "        initializer();",
            "    }",
            "    void initializer()",
            "    {",
            "        for (int i = 0; i < size; i++)",
            "        {",
            "            parent[i] = i;",
            "            rank[i] = 0;",
            "        }",
            "    }",
            "    int Find(int x)",
            "    {",
            "        if (parent[x] == x)",
            "            return x;",
            "        parent[x]=Find(parent[x]);",
            "        return parent[x];",
            "    }",
            "    void Union(int x, int y)",
            "    {",
            "        int x_rep = Find(x);",
            "        int y_rep = Find(y);",
            "",
            "        if (x_rep == y_rep)",
            "            return;",
            "        if (rank[x_rep] > rank[y_rep])",
            "            parent[y_rep] = x_rep;",
            "        else if (rank[y_rep] > rank[x_rep])",
            "            parent[x_rep] = y_rep;",
            "        else",
            "        {",
            "            parent[y_rep] = x_rep;",
            "            rank[x_rep]++;",
            "        }",
            "    }",
            "}; ",
            ""
        ],
        "description": "Disjoint Set"
    },
    "Prime": {
        "prefix": "prime",
        "body": [
            "vector<int> Prime_Sieve(ll n)",
            "{",
            "    vector<int> prime(n + 1, 1);",
            "    for (ll i = 2; i <= n; i++)",
            "    {",
            "        if (prime[i] != 1)",
            "            continue;",
            "        for (ll j = i * i; j <= n; j += i)",
            "        {",
            "            prime[j] = i;",
            "        }",
            "    }",
            "    return prime;",
            "}",
            "vector<int> Prime_Factor_Sieve(ll n, vector<int> Sieve)",
            "{",
            "    vector<int> factor;",
            "    while (Sieve[n] != 1)",
            "    {",
            "        factor.push_back(Sieve[n]);",
            "        n /= Sieve[n];",
            "    }",
            "    if (n != 1)",
            "        factor.push_back(n);",
            "    sort(factor.begin(), factor.end());",
            "    return factor;",
            "}"
        ],
        "description": "Prime"
    },
    "segmentTree": {
        "prefix": "segmentTree",
        "body": [
            "struct node",
            "{",
            "    ll val;",
            "    ll cnt;",
            "    // can add more if required or remove",
            "    node(ll v = 0, ll c = 0)",
            "    {",
            "        val = v;",
            "        cnt = c;",
            "    }",
            "};",
            "",
            "class segTree",
            "{",
            "public:",
            "    vector<node> segArr;",
            "    vector<ll> narr;",
            "",
            "    segTree(vector<ll> arr)",
            "    {",
            "        narr = arr;",
            "        int arrSize = arr.size();",
            "        narr = arr;",
            "        /*",
            " we are constructing tree in form of array linearly therefore",
            "we have to make 4*n size array for n size given array",
            "*/",
            "        segArr.resize(4 * arrSize);",
            "        constructSegTree(0, 0, arrSize - 1);",
            "    }",
            "",
            "    // here you can change the combine logic according to questions",
            "    node Combine(node &left, node &right)",
            "    {",
            "        return node(left.val + right.val, 0);",
            "    }",
            "",
            "    void constructSegTree(int index, int startIndx, int endIndx)",
            "    {",
            "        if (startIndx == endIndx)",
            "        {",
            "            // Leaf Logic",
            "            segArr[index] = node(narr[startIndx], 0);",
            "            return;",
            "        }",
            "        int midIndx = startIndx + (endIndx - startIndx) / 2;",
            "",
            "        constructSegTree(2 * index + 1, startIndx, midIndx);",
            "        constructSegTree(2 * index + 2, midIndx + 1, endIndx);",
            "        segArr[index] = Combine(segArr[2 * index + 1], segArr[2 * index + 2]);",
            "    }",
            "    node getQuery(int index, int startIndx, int endIndx, int lquery, int rquery)",
            "    {",
            "        // no overlap",
            "        if (startIndx > rquery || lquery > endIndx)",
            "            return node(0, 0);",
            "",
            "        // complete overlap",
            "        if (startIndx >= lquery && endIndx <= rquery)",
            "            return segArr[index];",
            "",
            "        // partial overlap",
            "        int midIndx = startIndx + (endIndx - startIndx) / 2;",
            "        node left = getQuery(index * 2 + 1, startIndx, midIndx, lquery, rquery);",
            "        node right = getQuery(index * 2 + 2, midIndx + 1, endIndx, lquery, rquery);",
            "",
            "        return Combine(left, right);",
            "    }",
            "",
            "    void updateQuery(int index, int startIndx, int endIndx, int position, int val)",
            "    {",
            "        if (position < startIndx || position > endIndx)",
            "            return;",
            "",
            "        if (startIndx == endIndx)",
            "        {",
            "            // Leaf Condition",
            "            segArr[index] = node(val, 0);",
            "            narr[startIndx] = val;",
            "            return;",
            "        }",
            "",
            "        int midIndx = startIndx + (endIndx - startIndx) / 2;",
            "        updateQuery(2 * index + 1, startIndx, midIndx, position, val);",
            "        updateQuery(2 * index + 2, midIndx + 1, endIndx, position, val);",
            "        segArr[index] = Combine(segArr[2 * index + 1], segArr[2 * index + 2]);",
            "    }",
            "",
            "    // Use To Get The result of the queries",
            "    void updateQuery(int postion, int value)",
            "    {",
            "        updateQuery(0, 0, (int)narr.size() - 1, postion, value);",
            "    }",
            "",
            "    node getQuery(int lquery, int rquery)",
            "    {",
            "        return getQuery(0, 0, (int)narr.size() - 1, lquery, rquery);",
            "    }",
            "};",
            "// use 0 based indexing while calling the update and query func"
        ],
        "description": "segmentTree"
    },
    "lazySegmentTree": {
        "prefix": "lazySegmentTree",
        "body": [
            "struct node",
            "{",
            "    ll val;",
            "    ll cnt;",
            "    // can add more if required or remove",
            "    node(ll v = 0, ll c = 0)",
            "    {",
            "        val = v;",
            "        cnt = c;",
            "    }",
            "};",
            "",
            "class segTree",
            "{",
            "public:",
            "    vector<node> segArr, lazy;",
            "    vector<ll> narr;",
            "",
            "    segTree(vector<ll> arr)",
            "    {",
            "        int arrSize = arr.size();",
            "        narr = arr;",
            "        /*",
            " we are constructing tree in form of array linearly therefore",
            "we have to make 4*n size array for n size given array",
            "*/",
            "        segArr.resize(4 * arrSize);",
            "        lazy.resize(4 * arrSize);",
            "        constructSegTree(0, 0, arrSize - 1);",
            "    }",
            "",
            "    // here you can change the combine logic according to questions",
            "    node Combine(node &left, node &right)",
            "    {",
            "        return node(left.val + right.val);",
            "    }",
            "",
            "    void constructSegTree(int index, int startIndx, int endIndx)",
            "    {",
            "        if (startIndx == endIndx)",
            "        {",
            "            // Leaf Logic",
            "            segArr[index] = node(narr[startIndx]);",
            "            return;",
            "        }",
            "        int midIndx = startIndx + (endIndx - startIndx) / 2;",
            "",
            "        constructSegTree(2 * index + 1, startIndx, midIndx);",
            "        constructSegTree(2 * index + 2, midIndx + 1, endIndx);",
            "        segArr[index] = Combine(segArr[2 * index + 1], segArr[2 * index + 2]);",
            "    }",
            "",
            "    node getQuery(int index, int startIndx, int endIndx, int lquery, int rquery)",
            "    {",
            "        // no overlap",
            "        if (startIndx > rquery || lquery > endIndx)",
            "            return node(0);",
            "",
            "        // lazy propagation / clear the lazy updates",
            "        if (lazy[index].val != 0)",
            "        {",
            "            // pending updates",
            "            // update the segmenet tree node",
            "            node newNode = node(lazy[index].val * (endIndx - startIndx + 1));",
            "            segArr[index] = Combine(segArr[index], newNode);",
            "            if (startIndx != endIndx)",
            "            {",
            "                // propagaetd the updated value",
            "                lazy[2 * index + 1] = Combine(lazy[2 * index + 1], lazy[index]);",
            "                lazy[2 * index + 2] = Combine(lazy[2 * index + 2], lazy[index]);",
            "            }",
            "            lazy[index] = node(0);",
            "        }",
            "",
            "        // complete overlap",
            "        if (startIndx >= lquery && endIndx <= rquery)",
            "            return segArr[index];",
            "",
            "        // partial overlap",
            "        int midIndx = startIndx + (endIndx - startIndx) / 2;",
            "        node left = getQuery(index * 2 + 1, startIndx, midIndx, lquery, rquery);",
            "        node right = getQuery(index * 2 + 2, midIndx + 1, endIndx, lquery, rquery);",
            "",
            "        return Combine(left, right);",
            "    }",
            "",
            "    void updateQuery(int index, int startIndx, int endIndx, int lquery, int rquery, int val)",
            "    {",
            "        // no overlap",
            "        if (startIndx > rquery || lquery > endIndx)",
            "            return;",
            "",
            "        // lazy propagation / clear the lazy updates",
            "        if (lazy[index].val != 0)",
            "        {",
            "            // pending updates",
            "            // update the segmenet tree node",
            "            node newNode = node(lazy[index].val * (endIndx - startIndx + 1));",
            "            segArr[index] = Combine(segArr[index], newNode);",
            "            if (startIndx != endIndx)",
            "            {",
            "                // propagaetd the updated value",
            "                lazy[2 * index + 1] = Combine(lazy[2 * index + 1], lazy[index]);",
            "                lazy[2 * index + 2] = Combine(lazy[2 * index + 2], lazy[index]);",
            "            }",
            "            lazy[index] = node(0);",
            "        }",
            "",
            "        // complete overlap",
            "        if (startIndx >= lquery && endIndx <= rquery)",
            "        {",
            "            node newNode = node(val * (endIndx - startIndx + 1));",
            "            segArr[index] = Combine(segArr[index], newNode);",
            "            if (startIndx != endIndx)",
            "            {",
            "                // propagaetd the updated value",
            "                node valNode = node(val);",
            "                lazy[2 * index + 1] = Combine(lazy[2 * index + 1], valNode);",
            "                lazy[2 * index + 2] = Combine(lazy[2 * index + 2], valNode);",
            "            }",
            "            return;",
            "        }",
            "",
            "        // partial overlap",
            "        int midIndx = startIndx + (endIndx - startIndx) / 2;",
            "        updateQuery(2 * index + 1, startIndx, midIndx, lquery, rquery, val);",
            "        updateQuery(2 * index + 2, midIndx + 1, endIndx, lquery, rquery, val);",
            "        segArr[index] = Combine(segArr[2 * index + 1], segArr[2 * index + 2]);",
            "    }",
            "",
            "    // Use To Get The result of the queries",
            "    void updateQuery(int l, int r, int value)",
            "    {",
            "        updateQuery(0, 0, (int)narr.size() - 1, l, r, value);",
            "    }",
            "",
            "    node getQuery(int lquery, int rquery)",
            "    {",
            "        return getQuery(0, 0, (int)narr.size() - 1, lquery, rquery);",
            "    }",
            "};",
            "// use 0 based indexing while calling the update and query func"
        ],
        "description": "lazySegmentTree"
    },
    "fenwickTree": {
        "prefix": "fenwickTree",
        "body": [
            "struct fenwick",
            "{",
            "    // considering 1 based indexing",
            "    vector<int> fenArr;",
            "    int n;",
            "    void init(int n)",
            "    {",
            "        this->n = n + 1;",
            "        fenArr.resize(this->n, 0);",
            "    }",
            "",
            "    // Building the fenwick tree",
            "    void add(int x, int y)",
            "    {",
            "        x++; // 1 based indexing",
            "        while (x < n)",
            "        {",
            "            fenArr[x] += y;",
            "",
            "            // adding the last set bit of x to x",
            "            x += (x & (-x)); // gives the last set bit",
            "        }",
            "    }",
            "",
            "    int sum(int x)",
            "    {",
            "        x++; // 1 based indxing",
            "        int ans = 0;",
            "        while (x > 0)",
            "        {",
            "            ans += fenArr[x];",
            "            x -= (x & (-x));",
            "        }",
            "        return ans;",
            "    }",
            "",
            "    int sum(int l, int r)",
            "    {",
            "        return sum(r) - sum(l - 1);",
            "    }",
            "};",
            "// here it is zero based indexing but internally in fenwick tree it is 1 based indexing",
            ""
        ],
        "description": "fenwickTree"
    },
    "stringHash": {
        "prefix": "stringHash",
        "body": [
            "class String_Hash",
            "{",
            "    vector<ll> hash, inv_pow, pow;",
            "    ll size, base, mod;",
            "",
            "public:",
            "    String_Hash(string s)",
            "    {",
            "        srand(time(NULL));",
            "        // use random value to avoid soln hacking of hasing",
            "        base = 107;",
            "        // set the prime mod val",
            "        mod = 1e9 + 7;",
            "        size = s.size() + 1;",
            "        hash.resize(size, 0);",
            "        inv_pow.resize(size, 0);",
            "        pow.resize(size, 0);",
            "        // precalc the power and inveerse power",
            "        preCalc();",
            "        // pre calc the hashes",
            "        buildHash(s);",
            "    }",
            "    void preCalc()",
            "    {",
            "        pow[0] = 1;",
            "        for (int i = 1; i < size; i++)",
            "        {",
            "            pow[i] = product(pow[i - 1], base, mod);",
            "        }",
            "        inv_pow[0] = 1;",
            "        ll pw_inv = power(base, mod - 2, mod);",
            "        for (int i = 1; i < size; i++)",
            "        {",
            "            inv_pow[i] = product(inv_pow[i - 1], pw_inv, mod);",
            "        }",
            "    }",
            "    void buildHash(string s)",
            "    {",
            "        hash[0] = 0;",
            "        for (int i = 1; i < size; i++)",
            "        {",
            "            // s[i-1]-'a' +1 bcoz for a val bcoz 0 and product remains 0 so we a to be 1",
            "            hash[i] = sum(hash[i - 1], product(s[i - 1] - 'a' + 1, pow[i - 1], mod), mod);",
            "        }",
            "    }",
            "    ll getHash(int l, int r)",
            "    {",
            "        // 1 based indexing",
            "        ll hres = diff(hash[r], hash[l - 1], mod);",
            "        hres = product(hres, inv_pow[l - 1], mod);",
            "        return hres;",
            "    }",
            "};",
            "// use 1 based indexing"
        ],
        "description": "stringHash"
    },
    "doubleStringHash": {
        "prefix": "doubleStringHash",
        "body": [
            "class DString_Hash",
            "{",
            "    vector<pair<ll, ll>> hash, inv_pow, pow;",
            "    ll size, base, mod1, mod2;",
            "",
            "public:",
            "    DString_Hash(string s)",
            "    {",
            "        srand(time(NULL));",
            "        // use random value to avoid soln hacking of hasing",
            "        base = 107;",
            "        // set the prime mod val use random big prime to avoid hacking of soln",
            "        mod2 = 1e9 + 21;",
            "        mod1 = 1e9 + 7;",
            "        size = s.size() + 1;",
            "        hash.resize(size);",
            "        inv_pow.resize(size);",
            "        pow.resize(size);",
            "        // precalc the power and inveerse power",
            "        preCalc();",
            "        // pre calc the hashes",
            "        buildHash(s);",
            "    }",
            "    void preCalc()",
            "    {",
            "        pow[0].first = 1;",
            "        pow[0].second = 1;",
            "        for (int i = 1; i < size; i++)",
            "        {",
            "            pow[i].first = product(pow[i - 1].first, base, mod1);",
            "            pow[i].second = product(pow[i - 1].second, base, mod2);",
            "        }",
            "        inv_pow[0].first = 1;",
            "        inv_pow[0].second = 1;",
            "        pair<ll, ll> pw_inv;",
            "        pw_inv.first = power(base, mod1 - 2, mod1);",
            "        pw_inv.second = power(base, mod2 - 2, mod2);",
            "",
            "        for (int i = 1; i < size; i++)",
            "        {",
            "            inv_pow[i].first = product(inv_pow[i - 1].first, pw_inv.first, mod1);",
            "            inv_pow[i].second = product(inv_pow[i - 1].second, pw_inv.second, mod2);",
            "        }",
            "    }",
            "    void buildHash(string s)",
            "    {",
            "        hash[0].first = 0;",
            "        hash[0].second = 0;",
            "        for (int i = 1; i < size; i++)",
            "        {",
            "            // s[i-1]-'a' +1 bcoz for a val bcoz 0 and product remains 0 so we a to be 1",
            "            hash[i].first = sum(hash[i - 1].first, product(s[i - 1] - 'a' + 1, pow[i - 1].first, mod1), mod1);",
            "            hash[i].second = sum(hash[i - 1].second, product(s[i - 1] - 'a' + 1, pow[i - 1].second, mod2), mod2);",
            "        }",
            "    }",
            "    pair<ll, ll> getHash(int l, int r)",
            "    {",
            "        // 1 based indexing",
            "        pair<ll, ll> hres;",
            "        hres.first = diff(hash[r].first, hash[l - 1].first, mod1);",
            "        hres.first = product(hres.first, inv_pow[l - 1].first, mod1);",
            "",
            "        hres.second = diff(hash[r].second, hash[l - 1].second, mod2);",
            "        hres.second = product(hres.second, inv_pow[l - 1].second, mod2);",
            "",
            "        return hres;",
            "    }",
            "};",
            "// use 1 based indexing",
            ""
        ],
        "description": "doubleStringHash"
    }
}